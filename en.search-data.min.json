[{"id":0,"href":"/readmehehe/","title":"Readmehehe","parent":"Geekdocs","content":"vue学习笔记    [toc]\n1. npm常用命令    # 初始化 npm init --yes # 表示安装到当前目录，并添加到开发依赖 npm install bootstrap --save-dev # 表示安装到当前目录，并添加到运行时依赖 npm install jquery 2. package.json解析    { \u0026#34;name\u0026#34;: \u0026#34;it_feng_vue3\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;this is IT峰播 vue3\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { // ^表示3.x.x最新版,3不会动，3是大版本变动比较大 \u0026#34;jquery\u0026#34;: \u0026#34;^3.6.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { // ~表示值更新5.0.x更新到最新版 \u0026#34;bootstrap\u0026#34;: \u0026#34;~5.0.2\u0026#34; } } 4. 使用babel 将es6语法转换成es5    4.1 在浏览器中使用babel    \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/babel-core/5.8.38/browser.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; const name = \u0026#34;study\u0026#34;; console.log(name) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.2 在服务端使用babel提前编译     使用npm全局安装babel-cli和转换成es5的插件  npm install babel-cli -g --save-dev npm install babel-core babel-preset-es2015 babel-plugin-transform-runtime babel-preset-stage-2 --save-dev 在项目目录下创建.babelrc文件  { \u0026#34;presets\u0026#34;:[\u0026#34;es2015\u0026#34;,\u0026#34;stage-2\u0026#34;], //设置转码规则 \u0026#34;plugins\u0026#34;: [\u0026#34;transform-runtime\u0026#34;] // 设置插件 } 修改package.json文件  \u0026#34;scripts\u0026#34;: { // babel ${source_dir} -w -d ${destion_dir} // -w 表示持续监听， -d指定目标 \u0026#34;build\u0026#34;: \u0026#34;babel src -w -d lib\u0026#34; } 5. webpack使用    5.1 安装webpack    # -D == --save-dev npm install webpack webpack-cli -D 5.2 webpack常用命令    # 打包dev webpack --mode development # 打包production webpack --mode production # 指定源及输出目录 webpack ./src/index.js -o ./build --mode development 5.3 webpack配置文件详解    5.3.1 在项目目录中创建文件webpack.config.js    const { resolve } = require(\u0026#39;path\u0026#39;) module.exports = { /* 1、entry 入口，指示webpack以哪个文件作为入口起点开始打包，分析构建内部依赖图，默认为./src/index.js */ entry: \u0026#39;./src/index.js\u0026#39;, // 2、output 输出，指示webpack打包后的资源bundles输出到哪里，以及如何命名  output: { // 输出的文件名  filename: \u0026#34;build.js\u0026#34;, // __dirname获取当前目录  path: resolve(__dirname, \u0026#39;build\u0026#39;) }, /* 3、loader 让webpack能够去处理那些非javascript资源，如css、image等; 将它们处理成webpack能识别的资源，可以理解成一个翻译过程; webpack自身只能理解js和json */ module: { rules: [] }, // 4、plugins 插件，可用于执行范围更广的任务；插件的范围包括：从打包优化和压缩，一直到重新定义环境变量等  plugins: [ ], // 5、模式，指示webpack使用的相应模式的配置；分为development何production；默认为production  mode: \u0026#34;development\u0026#34; } 5.3.2 多入口多出口情况    // 1. 单入口单出口  entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#34;build.js\u0026#34;, }, // 2. 多入口单出口  entry: [ \u0026#34;./src/index.js\u0026#34;, \u0026#34;./src/main.js\u0026#34; ], output: { filename: \u0026#34;build.js\u0026#34;, }, // 3. 多入口多出口  entry: { index: \u0026#39;./src/index.js\u0026#39;, main: \u0026#39;./src/main.js\u0026#39; }, output: { filename: \u0026#34;[name].js\u0026#34;, }, // 4. 特殊用法,多入口多出口  entry: { // one数组中的回打包成一个  one: [\u0026#39;./src/main.js\u0026#39;, \u0026#39;./src/index.js\u0026#39;], two: \u0026#39;./src/index.js\u0026#39; }, output: { filename: \u0026#34;[name].js\u0026#34;, }, 5.3.3 打包html/css/js    安装插件    npm install html-webpack-plugin -D npm install css-loader style-loader -D npm install less less-loader -D # npm install node-sass sass-loader -D npm install mini-css-extract-plugin -D 打包单个html    // 引用插件 const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) module.exports = { plugins: [ // 默认会创建一个新的index.html文件，目的就是自动引入打包的资源  new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, filename: \u0026#34;demo.html\u0026#34;, // 指定打包后的输出文件名  // 压缩资源  minify: { // 移除空格  collapseWhitespace: true, // 删除注释  removeComments: true } }) } 打包多个html    entry: { vendor: [\u0026#39;./src/js/jquery.js\u0026#39;, \u0026#39;./src/js/common.js\u0026#39;], // 形成一个chunk  index: [\u0026#39;./src/js/index.js\u0026#39;], cart: [\u0026#39;./src/js/cart.js\u0026#39;], }, output: { filename: \u0026#34;[name].js\u0026#34;, // __dirname获取当前目录  path: resolve(__dirname, \u0026#39;build\u0026#39;) }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, filename: \u0026#34;index.html\u0026#34;, // chunks: [\u0026#39;index\u0026#39;, \u0026#39;cart\u0026#39;,\u0026#39;vendor\u0026#39;], // 此处的chunk： index和vendor就是entry定义的  chunks: [\u0026#39;index\u0026#39;, \u0026#39;vendor\u0026#39;], minify: { collapseWhitespace: true, removeComments: true } }), new HtmlWebpackPlugin({ template: \u0026#34;./src/cart.html\u0026#34;, filename: \u0026#34;cart.html\u0026#34;, // chunks: [\u0026#39;cart\u0026#39;, \u0026#39;index\u0026#39;,\u0026#39;vendor\u0026#39;],  chunks: [\u0026#39;cart\u0026#39;,\u0026#39;vendor\u0026#39;], // 视频上说加载顺序是从后往前，但实测好像是根据chunk名称进行排序的，和列表顺序没有关系，上下New的两个，chunk顺序不一致，但打包后顺序是一样的  minify: { collapseWhitespace: true, removeComments: true } }), ], 打包css/less/sass文件    // css-loader 将css打包进js // style-loader 将css插入html中，如果css是单独的文件，就不需要这个loader const { resolve } = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#34;index.js\u0026#34;, path: resolve(__dirname, \u0026#39;build\u0026#39;) }, module: { rules: [ // test中写正则表达式去匹配文件，使用loader  { test: /\\.css$/, // 如果只有一个loader可以这么写 loader: \u0026#39;css-loader\u0026#39;  // 顺序是从右到左；先用css-loader打包到js文件，再通过style-loader插入到html中  use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] // 打包less  // { test: /\\.less$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;] }  // 打包sass  // { test: /\\.scss$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader\u0026#39;] }  }, ] }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, filename: \u0026#34;index.html\u0026#34;, }), ], mode: \u0026#34;development\u0026#34; } index.js\nrequire(\u0026#39;./style.css\u0026#39;) // require(\u0026#39;./lessstyle.less\u0026#39;) // require(\u0026#39;./sassstyle.scss\u0026#39;) console.log(\u0026#34;这是入口文件index.js\u0026#34;); lessstyle.less\n@width: 200px; @height: 200px; @color: red; #box2 { width: @width; height: @height; background: @color; color: green; } 提取css为单独文件    const MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;) module.exports = { module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, \u0026#39;css-loader\u0026#39;] } ] }, plugins: [ new MiniCssExtractPlugin({ filename: \u0026#39;index.css\u0026#39; }), ], } 处理css浏览器兼容性    # 安装插件 npm install post-loader postcss-loader postcss-preset-env -D webpack.config.js\nmodule.exports = { module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, \u0026#39;css-loader\u0026#39;, \u0026#39;postcss-loader\u0026#39;] } ] }, 新建一个文件src/postcss.config.js\nmodule.exports = { plugins: [ require(\u0026#39;postcss-preset-env\u0026#39;)() ] } package.json\n\u0026#34;browserslist\u0026#34;: [ \u0026#34;\u0026gt; 0.2%\u0026#34;, \u0026#34;last 2 versions\u0026#34;, \u0026#34;not dead\u0026#34; ] 压缩css    # 安装插件 npm install optimize-css-assets-webpack-plugin -D const OptimizeCssAssetsWebpackPlugin = require(\u0026#39;optimize-css-assets-webpack-plugin\u0026#39;); module.exports = { plugins: [ new OptimizeCssAssetsWebpackPlugin() ], } 打包图片资源    # 安装插件 npm install url-loader file-loader html-loader -D 在css中使用引入图片\nmodule: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, \u0026#39;css-loader\u0026#39;, \u0026#39;postcss-loader\u0026#39;] }, // { test: /\\.(png|jpeg|gif)$/, use: [\u0026#39;url-loader\u0026#39;, { \u0026#39;loader\u0026#39;: \u0026#39;file-loader\u0026#39;, options: {} }] },  { test: /\\.(png|jpeg|gif)$/, loader: \u0026#39;url-loader\u0026#39;, options: { publicPath: \u0026#39;./images/\u0026#39;, // 此时css中引入图片写的是./b.png, 打包后，会在css中自动加上./images/，默认情况下，会将图片以base64写入css文件中  outputPath: \u0026#39;images/\u0026#39;, // 将图片输出到build/images/目录下  limit: 1024 * 45, // 45kb以上的图片单独引入，45kb以下的以base64编码写入css文件中  name: \u0026#39;[name][hash:10].[ext]\u0026#39;, // 默认名称 \u0026#39;[hash].[ext]\u0026#39;  esModule: false, } }, ] } 在html文件中引入图片\nmodule: { rules: [ { test: /\\.html$/, loader: \u0026#39;html-url-loader\u0026#39; } ] src/index.html\n\u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;./a.jpeg\u0026#34; alt=\u0026#34;a\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; build/index.html\n\u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;./images/ab079421fb7e5ecbbf6a.jpeg\u0026#34; alt=\u0026#34;a\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; 打包其他资源：字体图标    # 安装插件 npm install file-loader -D module: { rules: [ { exclude: /\\.(js|json|html|css|less|scss|png|gif|jpg|jpeg)$/, loader: \u0026#39;file-loader\u0026#39;, options: { outputPath: \u0026#39;font/\u0026#39;, publicPath: \u0026#39;./font\u0026#39;, name: \u0026#39;[name].[ext]\u0026#39; } } ] } 6.使用eslint对js语法进行检查    # 安装eslint语法检查包 npm install eslint eslint-loader eslint-config-airbnb-base eslint-plugin-import -D 在webpack中配置使用，eslint是本身脱离webpack的，但可以在webpack中配置去使用\nmodule: rules:[ { test: /\\.js$/, // 只检查自己写的代码，不检查第三方库的代码  exclude: /node_modules/, loader: \u0026#39;eslint-loader\u0026#39;, options: { fix: true } } ] 在package.json中启用检查\n\u0026#34;eslintConfig\u0026#34;:{ \u0026#34;extends\u0026#34;:\u0026#34;airbnb-base\u0026#34; } js中添加注释，让下一行不用被检查\n// eslint-disable-next-line console.log(\u0026#39;this is less\u0026#39;); 7. 配置devServer    # 安装 npm install webpack-dev-server -D 在webpack.config.js中添加\nmodule.exports = { target: \u0026#34;web\u0026#34;, } # 启动webpack server webpack serve 将webpack server的参数写入package.json文件中\n\u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;webpack serve --mode development --port 3000\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack --mode production\u0026#34; } npm 启动\nnpm run dev npm run build 也可以将命令行参数写在webpack.config.js中\nmodule.exports = { devServer: { port: 3000, compress: true, // 压缩  open: true, // 自动打开浏览器  } } 8. 环境优化配置    8.1 开发环境优化    HMR(模块热替换) 在未使用HMR的时候，webpack serve在自动更新的时候，会从新加载所有文件；\n 开启HMR后，样式的HMR功能，需要在开发环境使用style-loader HTML的HMR功能，默认也没有HMR功能，需要在entry中引入html文件 js的HMR功能，默认没有HMR功能，只能处理非入口文件的js文件  在webpack.config.js中配置\ndevServer: { hot: true, }, 在入口的js文件中增加一个判断\nif(module.hot){ // 只对print.js进行热更新  module.hot.accept(\u0026#39;./print.js\u0026#39;, function(){ console.log(\u0026#34; print.js 这个文件发生了改变\u0026#34;) }) } 8.2 生产环境的优化(去除未被调用的代码)    只要使用es6语法去import，webpack在production环境编译会自动去除未被调用的js代码（这是webpack自带的tree-shaking功能，无需安装插件）\n// 从common.js中引入one和two两个函数 import {one, two} from \u0026#39;./common\u0026#39;; 去除未被调用的css\n# 安装 npm install purgecss-webpack-plugin -D 在webpack.config.js中配置\nconst PurgecssPlugin = require(\u0026#39;purgecss-webpack-plugin\u0026#39;); const glob = require(\u0026#39;glob\u0026#39;); const PATHS = { src: join(__dirname, \u0026#39;src\u0026#39;) } module.exports = { plugins: [ new PurgecssPlugin({ paths: glob.sync(`${PATHS.src}/**/*`, {nodir: true}), }), ] } 9. es6语法    9.1 箭头函数和this指向    箭头函数\n(x) =\u0026gt; { return x*x } // 1. 如果没有参数，或有多个参数就需要使用()来定义参数列表 const fun = () =\u0026gt; {return 100} // 2. 如果有一个参数，可以不用() // 3. 如果函数只有一条语句，可以不用大括号,return也可以不用写，会自动加 ; const func = x =\u0026gt; x*x const fun = x =\u0026gt; x*x; // const fun = x =\u0026gt; {return x*x} console.log(fun(100)) // 箭头函数在返回对象时，必须在对象外面加上小括号 const fun1 = id =\u0026gt; ({id:id, name:\u0026#39;hangsan\u0026#39;}) console.log(fun1(10).name) // let arr = [1,2,35,7,8,90] let narr = arr.sort((a,b)=\u0026gt;a-b) // 数组排序 let narr = arr.sort((a,b)=\u0026gt;b-a) console.log(narr) this指向\n// 普通函数的this，指向的是它的调用者，如果没有对象调用者则指向windows const obj = { fun: function(){ console.log(this) } } // 箭头函数的this,指向的是箭头函数定义时所处的对象，而不是箭头函数使用时所在的对象，默认使用父级this // 此处在全局中定义，所以此处的this是window const obj2 = { fun: ()=\u0026gt;{ console.log(this) } } obj.fun() obj2.fun() 9.2 数组中新增加的高级函数    filter\nlet goods = [30, 80, 50, 5, 3, 1, 60, 9] // 1. 取出大于10元的商品 let goods1 = goods.filter(function (n) { return n \u0026gt;= 10 }) console.log(goods1) map\n// 2. 将10元以上的商品打5折 let goods2 = goods1.map(function (n) { // 将goods1数组中的数，赋值给n，并将n给新数组goods2  return n * 0.5 }) console.log(goods2) reduce\n// 3. 打完折的商品总价是多少 let sum = goods2.reduce(function (s, n) { /* 第一次s为0, n为goods2数组的第一个元素 第二次s为函数的返回值，n为goods2数组的第二个元素 */ return s + n }, 0) console.log(sum) 链式编程一次性完成上面3个需求\nlet goods = [30, 80, 50, 5, 3, 1, 60, 9] let sum = goods.filter(n =\u0026gt; n \u0026gt;= 10).map(n =\u0026gt; n * 0.5).reduce((s, n) =\u0026gt; s + n) console.log(sum) 9.3 map和set    数据结构Set\nconst obj = new Set() // 可以使用foreach  obj.add(1) obj.add([\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;]) // 无法添加重复数值进去 obj.add(1) console.log(obj) // 判断是否存在某个数值,存在返回true console.log(obj.has(1)) // 删除数值,成功返回true console.log(obj.delete(1)) console.log(obj.delete(1)) // 获取Set的长度 console.log(obj.size) 数据结构Map\nconst obj1 = new Map() // 可以使用foreach  // 设置键值对 obj1.set(\u0026#34;one\u0026#34;, 1111) obj1.set(\u0026#34;two\u0026#34;, 2222) // 根据键获取值 console.log(obj1.get(\u0026#34;one\u0026#34;)) // 删除,成功返回true obj1.delete(\u0026#34;one\u0026#34;) 9.4 模板字符串    let name = \u0026#34;尤玉希\u0026#34; let vvv = `vue ${name}` let ccc = `第一行 第二行 第三行 ` console.log(vvv) console.log(ccc) 9.5 解构赋值和扩展运算符号    // 解构数组 let arr = [1, 2, 3] let [a, b, c] = arr console.log(a, b, c) // 三点扩展运算符...arr和golang当中的用法一样，将数组展开 let arr1 = [...arr, 7, 8, 9] console.log(arr1) // 解构对象,键名必须一致 let obj = { name: \u0026#34;zhangsan\u0026#34;, age: 18, sex: \u0026#34;man\u0026#34; } let { name, age, sex } = obj console.log(name, age, sex) 9.6 class的用法和json新应用    class的使用\nclass Person { // 构造方法  constructor(name, age, sex) { this.name = name this.age = age this.sex = sex } // 定义方法  say() { console.log(this.name) console.log(this.age) console.log(this.sex) } } // 继承 class Student extends Person { constructor(name, age, sex, school) { // 此处使用父类的构造方法初始化name,age,sex  super(name, age, sex) this.school = school } study() { console.log(this.school) } } // const p = new Person(\u0026#34;张三\u0026#34;, 20, \u0026#34;man\u0026#34;) // console.log(p) // p.say()  const s = new Student(\u0026#34;李四\u0026#34;, 18, \u0026#34;man\u0026#34;, \u0026#34;新东方\u0026#34;) console.log(s) s.say() s.study() json的新用法\nlet name = \u0026#34;网二\u0026#34; let age1 = 30 // const obj = { name: name, age: age1, sex: \u0026#34;男\u0026#34; } // 如果键名和值名一致，可以简写 const obj = { name, age: age1, sex: \u0026#34;男\u0026#34; } console.log(obj) // const obj1 = { // name, age: age1, sex: \u0026#34;男\u0026#34;, say: function () { // console.log(\u0026#34;say\u0026#34;) // } // }  // 可以简写成 obj1 = { name, age: age1, sex: \u0026#34;男\u0026#34;, say() { console.log(\u0026#34;say\u0026#34;) } } obj1.say() // 将对象转为字符串 python中的序列化，go当中的json.marshal let objStr = JSON.stringify(obj) console.log(objStr) // 将字符串转为json对象 let o = JSON.parse(objStr) console.log(o) 9.7 module模块化编程export和import    方式一    module_one.js\nlet name = \u0026#34;张三\u0026#34; let age = 18 function add(x, y) { return x + y } export { name, age, add } module.js\nimport { add } from \u0026#34;./module_one.js\u0026#34; // 设置别名 import { add as module_ad } from \u0026#34;./module_one.js\u0026#34; console.log(add(2, 3)) console.log(module_ad(3, 5)) html中引入js模块\n\u0026lt;script src=\u0026#34;module.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 方式二，导出函数允许自定义命名    module_one.js 导出\nexport default function (args) { console.log(args) } module.js 导入\nimport printx from \u0026#34;./module_one.js\u0026#34; printx(\u0026#34;hello world\u0026#34;) 方式三：导出取别名与导入全部    module_one.js\nlet name = \u0026#34;张三\u0026#34; let age = 18 function add(x, y) { return x + y } export { name as nnn, age, add }; module_two.js\nlet two = \u0026#34;two\u0026#34; let ttt = \u0026#34;ttt\u0026#34; function add(x, y) { return x + y } export { two, ttt, add } module.js\nimport { nnn } from \u0026#34;./module_one.js\u0026#34; console.log(nnn) import * as two from \u0026#34;./module_two.js\u0026#34; console.log(two.add(200, 300)) 10 axios与promise    10.1 promise的使用    主要用于异步计算，可以将异步操作队列化，按照期望的顺序执行；解决回调地狱\n// 此处传两个函数名 new Promise((resolve,reject)=\u0026gt;{ console.log(\u0026#34;这是第一层\u0026#34;) // resolve和reject只能生效一个  // 有优先级，从上到下  // resolve表示true，会执行.then(par1,par2)的第一个参数所代表的箭头函数  // reject表示false，会执行.then(par1,par2)的第二个参数所代表的箭头函数  reject(\u0026#34;这是一个错误\u0026#34;) resolve(\u0026#34;这是第二2层\u0026#34;) }).then(res=\u0026gt;{ console.log(res) /* 这里的res，是 new Promise((resolve,reject)=\u0026gt;{}) 中的resolve函数的值 */ /* 如果还想继续执行，可以return一个Promise return new Promise((resolve,reject)=\u0026gt;{ }) */ },err=\u0026gt;{ console.log(err) } ) .then继续执行的三种写法\nnew Promise((resolve,reject)=\u0026gt;{ console.log(\u0026#34;这是第一层\u0026#34;) resolve(\u0026#34;这是第二2层\u0026#34;) }).then(res=\u0026gt;{ console.log(res) // 方式一：  // return new Promise((resolve,reject)=\u0026gt;{  // resolve(\u0026#34;这是第三3层\u0026#34;)  // })  // 方式二：  // return Promise.resolve(\u0026#34;这是第三层\u0026#34;)  // 方式三：  // return {mess:\u0026#34;这是第三层\u0026#34;}  // PS：方式2、3会遇到一个问题，如果使用settimeout()这种方式，无法调用到mess  // setTimeout(()=\u0026gt;{  // return {mess:\u0026#34;这是第三层\u0026#34;}  // })  return new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve({mess:\u0026#34;这是第三层\u0026#34;}) },1000) }) },err=\u0026gt;{ console.log(err) } ).then(res=\u0026gt;{ console.log(res.mess) }) 错误处理,在最后增加一个链式调用函数.catch(err=\u0026gt;{})\nnew Promise((resolve,reject)=\u0026gt;{ console.log(\u0026#34;这是第一层\u0026#34;) reject(\u0026#34;这是一个错误\u0026#34;) }).then(res=\u0026gt;{ console.log(res) return new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve({mess:\u0026#34;这是第三层\u0026#34;}) },1000) }) },err=\u0026gt;{ console.log(err) }).then(res=\u0026gt;{ console.log(res.mess) }).catch(err=\u0026gt;{ console.log(\u0026#34;catch err: \u0026#34;, err) }) 并行处理\n// 传递一个数组 Promise.all([ new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve(\u0026#34;这是第一个请求\u0026#34;) },1000) }), new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ resolve(\u0026#34;这是第二个请求\u0026#34;) },1000) }), ]).then(res=\u0026gt;{ // res接收一个数组  console.log(res) console.log(res[1]) console.log(res[0]) }) 10.2 axios的使用    10.2.1 axios的初步使用    02_axios.html 中引用\n\u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;02_axios.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 02_data.json\n{ \u0026#34;age\u0026#34;: 18 } 02_axios.js\n// 默认使用Get方式请求(需要注意跨域) axios(\u0026#39;http://127.0.0.1:5500/04_axios/02_data.json\u0026#39;).then(res=\u0026gt;{ console.log(res) console.log(res.data) }) 10.2.2 axios的传参    get方式\naxios({ method: \u0026#34;get\u0026#34;, url: \u0026#39;http://127.0.0.1:5500/04_axios/02_data.json\u0026#39;, params: { username: \u0026#34;alex\u0026#34;, age: 18, sex: \u0026#34;man\u0026#34; } }).then(res=\u0026gt;{ console.log(res) console.log(res.data) }) post方式\naxios({ method: \u0026#34;post\u0026#34;, url: \u0026#39;http://127.0.0.1:5500/04_axios/02_data.json\u0026#39;, Headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, data: { username: \u0026#34;alex\u0026#34;, age: 18, sex: \u0026#34;man\u0026#34; } }).then(res=\u0026gt;{ console.log(res) console.log(res.data) }) 10.2.3 生产环境使用axios     npm初始化  npm init npm install webpack webpack-cli -D npm install html-webpack-plugin -D # 安装axios npm install axios 编写webpack.config.js文件  const HtmlWebapckPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, plugins: [ new HtmlWebapckPlugin({ template: \u0026#34;./src/index.html\u0026#34; // index.html不用引入index.js，插件会自动引入  }) ], mode: \u0026#34;development\u0026#34;, } src/index.js中使用axios  import axios from \u0026#34;axios\u0026#34; // 第一种get传参方式 axios.get(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data.json?id=1\u0026#34;).then(res=\u0026gt;{ console.log(res.data) }) // 第二种get传参方式 axios.get(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data.json\u0026#34;,{params:{id:1}}).then(res=\u0026gt;{ console.log(res.data) }) // 第一种post传参方式,默认将content-type设置application/x-www-form-urlencoded axios.post(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data.json\u0026#34;, \u0026#34;name=测试\u0026amp;age=18\u0026amp;sex=man\u0026#34;).then(res =\u0026gt; { console.log(res.data) }) // 第二种post传参方式,在axios中，默认将content-type设置为application/json axios.post(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data.json\u0026#34;, {\u0026#34;name\u0026#34;:\u0026#34;测试\u0026#34;,\u0026#34;age\u0026#34;:18}).then(res =\u0026gt; { console.log(res.data) }) 10.2.4 axios的并发请求    axios.all([ axios.get(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data.json\u0026#34;), axios.get(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data1.json\u0026#34;), ]).then(res=\u0026gt;{ console.log(res) console.log(res[0]) console.log(res[1]) }).catch(err=\u0026gt;{ console.log(\u0026#34;-----------------error------------------\u0026#34;) console.log(err) }) 将并发请求挨个用不同变量接收\naxios.all([ axios.get(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data.json\u0026#34;), axios.get(\u0026#34;http://127.0.0.1:5500/04_axios/demo/src/data1.json\u0026#34;), ]).then( axios.spread((res1,res2)=\u0026gt;{ console.log(res1.data) console.log(res2.data) }) ).catch(err=\u0026gt;{ console.log(\u0026#34;-----------------error------------------\u0026#34;) console.log(err) }) 10.2.5 axios的全局配置    axios.defaults.baseURL=\u0026#34;http://127.0.0.1:5500\u0026#34; axios.defaults.timeout=5000 // 单位毫秒 // post默认为application/json axios.defaults.headers.post[\u0026#39;content-type\u0026#39;]=\u0026#39;application/x-www-form-urlencoded\u0026#39; 10.2.6 axios的实例封装    将每个服务器单独封装成一个实例\nlet eduwork = axios.create({ baseURL: \u0026#34;http://127.0.0.1:5500\u0026#34;, timeout: 5000, // method: post,  // 如果指定了默认请求方法，可以直接使用eduwork()去使用 }) let local1 = axios.create({ baseURL: \u0026#34;http://localhost:5500\u0026#34;, timeout: 2000, }) eduwork.get(\u0026#34;04_axios/demo/src/data.json\u0026#34;).then(res=\u0026gt;{ console.log(res) }) 10.2.7 axios的拦截器    let eduwork = axios.create({ baseURL: \u0026#34;http://127.0.0.1:5500\u0026#34;, timeout: 5000, }) eduwork.interceptors.request.use(config=\u0026gt;{ console.log(\u0026#34;请求拦截器\u0026#34;) // 这里的return config，表示的是放行  return config }, err=\u0026gt;{ console.log(err) }) eduwork.interceptors.response.use(config=\u0026gt;{ console.log(\u0026#34;从服务器将数据带回来了\u0026#34;) // 只放行服务器返回的数据  return config.data }, err=\u0026gt;{ console.log(err) }) eduwork.get(\u0026#34;04_axios/demo/src/data.json\u0026#34;).then(res=\u0026gt;{ console.log(res) }) 11 vue3的学习    11.1 基本使用    11.1.1 cdn的方式使用vue3    demo.html\n\u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@next\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{message}} \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;demo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; demo.js\n// 创建 const app = Vue.createApp({ data() { // 此处只是声明数据  return { message: \u0026#39;this is a test data\u0026#39; } } // 挂载方式1 }).mount(\u0026#34;#app\u0026#34;); app.message = \u0026#34;aaaaaa\u0026#34; // 挂载方式2 // const vm = app.mount(\u0026#34;#app\u0026#34;); 11.1.2    11.2 v-for循环    demo.html\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue@next\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{message}} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- :属性名,这样可以绑定属性，并且使用vue定义的数据 --\u0026gt; \u0026lt;li v-for=\u0026#34;itme in title\u0026#34; :title=\u0026#34;itme.msg\u0026#34;\u0026gt;{{itme.msg}}\u0026lt;/li\u0026gt; \u0026lt;!-- 只要前3个 --\u0026gt; \u0026lt;!-- \u0026lt;li v-for=\u0026#34;itme in title.slice(0,3)\u0026#34;\u0026gt;{{itme.msg}}\u0026lt;/li\u0026gt; --\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;demo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; demo.js\nconst app = Vue.createApp({ data() { return { message: \u0026#39;this is a test data\u0026#39;, title: [ { msg: \u0026#34;11111\u0026#34; }, { msg: \u0026#34;22222\u0026#34; }, { msg: \u0026#34;33333\u0026#34; }, { msg: \u0026#34;44444\u0026#34; }, { msg: \u0026#34;55555\u0026#34; }, ] } } }).mount(\u0026#34;#app\u0026#34;); 11.3 绑定属性    \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div id=\u0026#34;app\u0026#34; :sytle=\u0026#34;{width,height}\u0026#34;\u0026gt; 这样是不生效的--\u0026gt; \u0026lt;!-- \u0008:style 只能作用在锚定的标签之下的标签，而不能在锚定标签内直接使用 --\u0026gt; \u0026lt;div :style=\u0026#34;{width,height,color:\u0026#39;red\u0026#39;,background:\u0026#39;yellow\u0026#39;}\u0026#34;\u0026gt;{{message}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 11.4 自定义方法    demo.js\nconst app = Vue.createApp({ data() { }, methods: { myShow() { console.log(\u0026#34;heheheh\u0026#34;) } } }).mount(\u0026#34;#app\u0026#34;); demo.html\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div @click=\u0026#34;myShow()\u0026#34;\u0026gt;{{message}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34; vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;demo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 11.5 vue脚手架    11.5.1 安装vue脚手架    默认已经帮搭建好了一套利用webpack管理vue的项目结构\nnpm install -g @vue/cli # 查看版本 vue -V # 创建项目demo1 vue create demo1 ## Default (Vue 3) ([Vue 3] babel, eslint) ## Manually select features 11.5.2 vue.config.js配置文件    官方文档：https://cli.vuejs.org/config/#global-cli-config vue.config.js\nconst webpack = require(\u0026#39;webpack\u0026#39;) module.exports = { outputDir: \u0026#39;build\u0026#39;, // 使用webpack配置  configureWebpack: { plugins: [ // 给所有打包后的trunk都添加注释  new webpack.BannerPlugin({ banner: \u0026#39;学习vue\u0026#39; }) ] } } 11.5.3 初步使用vue组件    main.js\nimport { createApp } from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App\u0026#39;; createApp(App).mount(\u0026#39;#app\u0026#39;); App.vue\n// 组件名第一个字母要大写 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ msg }} {{ msg }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return { msg: \u0026#39;######\u0026#39; }; }, }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 11.5.4 eslint自动修复    package.json 添加lint，使用npm run lint自动修复\n\u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint --fix src \u0026#34; } 注意事项： 从别的地方拷贝的App.vue和main.js文件，需要在引入./App的时候添加.vue后缀 main.js\nimport App from \u0026#39;./App.vue\u0026#39;; 11.6 options基础定义与v-model    main.js\nimport { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App\u0026#39; createApp(App).mount(\u0026#39;#app\u0026#39;) App.vue\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ msg }} {{ num }} \u0026lt;br /\u0026gt; \u0026lt;!-- \u0026lt;button @click=\u0026#34;num--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;button @click=\u0026#34;sub\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; size=\u0026#34;3\u0026#34; v-model=\u0026#34;num\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; const data = { msg: \u0026#39;hello vue\u0026#39;, num: 0, max: 10, min: 1, } export default { name: \u0026#39;App\u0026#39;, data() { return data }, methods: { add() { if (this.num \u0026gt;= this.max) { this.num = this.max } else { this.num++ } }, sub() { if (this.num \u0026lt;= this.min) { this.num = this.min } else { this.num-- } }, }, } \u0026lt;/script\u0026gt; 11.7 模板基础语法    11.7.1 插值操作    插值：{{}} 指令：v-\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ msg + \u0026#39;\u0026#39; + str }}\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;{{ num + num }}\u0026lt;/h1\u0026gt; \u0026lt;!-- 将标签内的插值认为是普通字符串，不进行解析 --\u0026gt; \u0026lt;h1 v-pre\u0026gt;{{ msg }}\u0026lt;/h1\u0026gt; \u0026lt;!-- 只使用初值，如果使用方法修改bum的值，修改的值在这里不生效 --\u0026gt; \u0026lt;button @click=\u0026#34;num--\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;h2 v-once\u0026gt;{{ num }}\u0026lt;/h2\u0026gt; \u0026lt;!-- 像标签内插入文本，很少用 --\u0026gt; \u0026lt;h2 v-text=\u0026#34;11111\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;!-- 可以插入标签 --\u0026gt; \u0026lt;h2 v-html=\u0026#34;url\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; {{ url }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return { msg: \u0026#39;this is test\u0026#39;, str: \u0026#39;hello vue\u0026#39;, num: 100, url: \u0026#39;\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt;\u0026#39;, } }, methods: {}, } \u0026lt;/script\u0026gt; 11.7.2 v-bind使用    v-bind: 双向数据绑定 语法： v-bind:${attribute} 例： v-bind:title=\u0026ldquo;this is a test\u0026rdquo; 语法糖 : 例： :title=\u0026ldquo;this is a test\u0026rdquo;\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 title=\u0026#34;this is a test title\u0026#34;\u0026gt;{{ msg }}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-bind:title=\u0026#34;msg\u0026#34;\u0026gt;{{ msg }}\u0026lt;/h2\u0026gt; \u0026lt;h2 :title=\u0026#34;msg\u0026#34;\u0026gt;{{ msg }}\u0026lt;/h2\u0026gt; \u0026lt;img :src=\u0026#34;imgsrc\u0026#34; :width=\u0026#34;size\u0026#34; :height=\u0026#34;size\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div :style=\u0026#34;[fontSize, bgcolor]\u0026#34;\u0026gt;box\u0026lt;/div\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;!-- 这里会直接使用下方style中定义的样式 --\u0026gt; \u0026lt;div class=\u0026#34;one two\u0026#34;\u0026gt;cls1\u0026lt;/div\u0026gt; \u0026lt;!-- cls2这里的:class=\u0026#34;one\u0026#34;，会去data中找one这个变量 --\u0026gt; \u0026lt;div :class=\u0026#34;one\u0026#34;\u0026gt;cls2\u0026lt;/div\u0026gt; \u0026lt;!-- 这里会直接使用下方style中定义的样式 --\u0026gt; \u0026lt;div :class=\u0026#34;\u0026#39;one two\u0026#39;\u0026#34;\u0026gt;cls3\u0026lt;/div\u0026gt; \u0026lt;!-- 这里的:class=\u0026#34;[one, two]，回去data中找one two这两个变量 --\u0026gt; \u0026lt;div :class=\u0026#34;[one, two]\u0026#34;\u0026gt;cls4\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;actice\u0026#34;\u0026gt;cls5\u0026lt;/div\u0026gt; \u0026lt;!-- 对象类型，键one下方style中的one，值为data中的一个布尔型,true表示使用该属性，false表示不使用 --\u0026gt; \u0026lt;div :class=\u0026#34;{ one: isone, two: istwo }\u0026#34;\u0026gt;cls6\u0026lt;/div\u0026gt; \u0026lt;!-- 当样式名称和data中布尔类型的变量一样时，可以简写 --\u0026gt; \u0026lt;div :class=\u0026#34;{ demo1, demo2 }\u0026#34;\u0026gt;cls6\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;getStyleArr()\u0026#34;\u0026gt;cls7\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;getStyleObj()\u0026#34;\u0026gt;cls8\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return { msg: \u0026#39;this is test\u0026#39;, imgsrc: \u0026#39;https://img1.baidu.com/it/u=1334019890,3170066037\u0026amp;fm=26\u0026amp;fmt=auto\u0026amp;gp=0.jpg\u0026#39;, size: 200, fontSize: \u0026#39;font-size:100px\u0026#39;, bgcolor: \u0026#39;background-color:green\u0026#39;, one: \u0026#39;one\u0026#39;, two: \u0026#39;two\u0026#39;, actice: [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;], isone: true, istwo: false, demo1: true, demo2: true, } }, methods: { getStyleArr() { return [this.one, this.two] }, getStyleObj() { return { one: this.isone, two: this.istwo } }, }, } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .one { background: red; } .two { font-size: 30px; } .demo1 { background: green; } .demo2 { font-size: 30px; } \u0026lt;/style\u0026gt; 11.7.3 计算属性computed    有缓存作用\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{ name }}-{{ slogen }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ name + \u0026#39;-\u0026#39; + slogen }}\u0026lt;/h2\u0026gt; \u0026lt;!-- 此处2被调用了几次就打印几次 --\u0026gt; \u0026lt;h2\u0026gt;{{ getTitle() }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ getTitle() }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ getTitle() }}\u0026lt;/h2\u0026gt; \u0026lt;!-- 此处不是调用方法，用的是属性，计算属性有缓存作用,此处1只打印了1次 --\u0026gt; \u0026lt;h2\u0026gt;{{ title }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ title }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ title }}\u0026lt;/h2\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;small\u0026gt;￥{{ totalPrice }}\u0026lt;/small\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;学习\u0026#39;, slogen: \u0026#39;成就自己\u0026#39;, books: [ { id: 1, name: \u0026#39;《操作系统原理》\u0026#39;, price: 188 }, { id: 2, name: \u0026#39;《操作系统真相还原》\u0026#39;, price: 88 }, { id: 3, name: \u0026#39;《c语言从入门到入土》\u0026#39;, price: 66 }, { id: 4, name: \u0026#39;《k8s》\u0026#39;, price: 99 }, ], } }, computed: { totalPrice: { get() { // reduce((s, n)中的s表示箭头函数右边的返回值， 0表示第一次s为0 \t// 循环这个books，依次取出元素，并赋值给n； \t// 第一次表示 reduce(0,{ id: 1, name: \u0026#39;《操作系统原理》\u0026#39;, price: 188 }) =\u0026gt;0+188 \t// 第二次表示 reduce(188,{ id: 2, name: \u0026#39;《操作系统真相还原》\u0026#39;, price: 88 }) =\u0026gt; 188+88 \t// 第三次表示 reduce(276,{ id: 3, name: \u0026#39;《c语言从入门到入土》\u0026#39;, price: 66 }) =\u0026gt; 276+66 \t// 第四次表示 reduce(342,{ id: 4, name: \u0026#39;《k8s》\u0026#39;, price: 99 }) =\u0026gt; 342+99 \treturn this.books.reduce((s, n) =\u0026gt; s + n.price, 0) }, }, title: { get() { console.log(\u0026#39;1111111\u0026#39;) return this.name + \u0026#39;-\u0026#39; + this.slogen }, // set基本不用 \tset(values) { let arr = values.split(\u0026#39;-\u0026#39;) this.name = arr[0] this.slogen = arr[1] }, }, }, methods: { getTitle() { console.log(\u0026#39;222222\u0026#39;) // 此处调用的是computed中的set \tthis.title = \u0026#39;学习 - slogen\u0026#39; return this.name + \u0026#39;-\u0026#39; + this.slogen }, }, } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 11.7.4 事件监听v-on    "},{"id":1,"href":"/","title":"Geekdocs","parent":"","content":""},{"id":2,"href":"/tags/","title":"Tags","parent":"Geekdocs","content":""}]